import type { SupabaseClient } from "@supabase/supabase-js"
import { VulnerabilityRepository } from "../repositories/vulnerability.repository"
import { ComponentRepository } from "../repositories/component.repository"
import { NotificationService } from "./notification.service"
import { ScanningError } from "../errors"

interface OSVVulnerability {
  id: string
  summary?: string
  details?: string
  severity?: Array<{
    type: string
    score: string
  }>
  database_specific?: {
    severity?: string
  }
}

interface OSVResponse {
  vulns?: OSVVulnerability[]
}

export class VulnerabilityScanner {
  private vulnerabilityRepo: VulnerabilityRepository
  private componentRepo: ComponentRepository

  constructor(private supabase: SupabaseClient) {
    this.vulnerabilityRepo = new VulnerabilityRepository(supabase)
    this.componentRepo = new ComponentRepository(supabase)
  }

  async scanComponent(componentId: string, purl: string): Promise<number> {
    try {
      const controller = new AbortController()
      const timeoutId = setTimeout(() => controller.abort(), 15000)

      const response = await fetch("https://api.osv.dev/v1/query", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ package: { purl } }),
        signal: controller.signal,
      })

      clearTimeout(timeoutId)

      if (!response.ok) {
        if (response.status >= 500) {
          console.warn(`OSV.dev service unavailable (${response.status}). Using cached data.`)
          return 0
        }
        throw new ScanningError(`OSV.dev API error: ${response.status}`)
      }

      const result: OSVResponse = await response.json()

      if (!result.vulns || result.vulns.length === 0) {
        return 0
      }

      let insertedCount = 0
      for (const vuln of result.vulns) {
        const existing = await this.vulnerabilityRepo.findByCveId(vuln.id)
        if (existing) continue

        const severity = this.mapSeverity(vuln)

        await this.vulnerabilityRepo.create({
          component_id: componentId,
          cve_id: vuln.id,
          severity,
          status: "Open",
          remediation_notes: vuln.summary || null,
        })

        insertedCount++
      }

      return insertedCount
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        console.warn(`OSV.dev request timeout for component ${componentId}. Using cached data.`)
        return 0
      }

      if (error instanceof TypeError && error.message.includes('fetch')) {
        console.warn(`Network error scanning component ${componentId}. Using cached data.`)
        return 0
      }

      console.error(`[VulnerabilityScanner] Error scanning component ${componentId}:`, error)
      throw error instanceof ScanningError ? error : new ScanningError("Vulnerability scan failed")
    }
  }

  async scanMultipleComponents(purls: string[]): Promise<Map<string, OSVResponse>> {
    const results = new Map<string, OSVResponse>()

    const batchSize = 10
    for (let i = 0; i < purls.length; i += batchSize) {
      const batch = purls.slice(i, i + batchSize)

      const promises = batch.map(async (purl) => {
        try {
          const response = await fetch("https://api.osv.dev/v1/query", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ package: { purl } }),
          })

          if (!response.ok) return null

          const result: OSVResponse = await response.json()
          return { purl, result }
        } catch {
          return null
        }
      })

      const batchResults = await Promise.all(promises)

      for (const item of batchResults) {
        if (item) {
          results.set(item.purl, item.result)
        }
      }

      if (i + batchSize < purls.length) {
        await this.delay(500)
      }
    }

    return results
  }

  async notifyAssignee(
    vulnerabilityId: string,
    componentName: string,
    userEmail: string
  ): Promise<void> {
    const vulnerability = await this.vulnerabilityRepo.findById(vulnerabilityId)
    if (!vulnerability) return

    await NotificationService.sendNewVulnerabilityAlert(
      userEmail,
      vulnerability.cve_id,
      vulnerability.severity,
      componentName
    )
  }

  private mapSeverity(vuln: OSVVulnerability): "Critical" | "High" | "Medium" | "Low" {
    if (vuln.database_specific?.severity) {
      const dbSeverity = vuln.database_specific.severity.toUpperCase()
      if (dbSeverity === "CRITICAL") return "Critical"
      if (dbSeverity === "HIGH") return "High"
      if (dbSeverity === "MODERATE" || dbSeverity === "MEDIUM") return "Medium"
      if (dbSeverity === "LOW") return "Low"
    }

    if (vuln.severity && vuln.severity.length > 0) {
      for (const sev of vuln.severity) {
        if (sev.type === "CVSS_V3") {
          const score = parseFloat(sev.score)
          if (score >= 9.0) return "Critical"
          if (score >= 7.0) return "High"
          if (score >= 4.0) return "Medium"
          return "Low"
        }
      }
    }

    return "Medium"
  }

  private delay(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms))
  }
}
